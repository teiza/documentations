# Введение в алгоритмы

- алгоритм - последовательность шагов, которые решают определенную задачу
- эффективность алгоритма - время

Типы алгоритмов (в порядке уменьшения эффективности):
- Константный O(1) - приложение выполняет фиксированное кол-во операций, которые, как правило, требуют постоянного времени
- Логарифмический O(log N) - пример алгоритм бинарного поиска
- Линейный O(N) - один цикл
- Линейно-логарифмический O(Nlog N) - сортировка слиянием
- Квадратичный O(n^2) - два цикла
- Кубический O(n^3) - три цикла

# Глупая сортировка O(n^3)

Сравнивает два элемента массива, если один больше другого, меняет местами и возвращается в начало. Шаги повторяются пока не отсортируется массив.

# Гномья сортировка O(n^2)

В отличие от **глупой** не возвращается в начало, а делает шаг назад и проверяется с предыдущим элементом. Если все хорошо, идет вперед, в противном случае шаг назад.

# Пузырьковая сортировка O(n^2)

Отличается от **глупой сортировки** тем, что не возвращается в начало после перестановки.

# Шейкерная сортировка O(n^2)

Разновидность **пузырьковой сортировки**.

Не только задвигает максимумы в конец, но и передвигает минимумы в начало.

1) Начинается как пузырьковая - перемещает максимум в конец
2) Разворачивается на 180 градусов
3) Перетаскивает минимум в начало
4) Процесс заканчивается в середине

# Сортировка расческой O(n^2)

- улучшает **пузырьковую/шейкерную**. Если при этих сортировках при переборе массива сравниваются соседние элементы.
- сравниваются элементы на промежутка

При расчесывании, сначала берется достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.

# Сортировка выбором O(n^2)

- неустойчивая (одинаковые элементы могут нарушить свой порядок)

Кратко. Массив разделяется на две части (сортированная и нет). На каждом шаге число переходит от неотсортированной части к сортированной, и так пока все числе не окажутся в отсортированной части.

Шаги:
1) Все значения неотсортированны. Находим минимальное число в этой части.
2) Меняем его с первым среди неотсортированных, и ставим его в конце сортированного массива
3) Сдвигается на позицию вправо
4) Начинаем искать минимальное уже со второго элемента, затем шаг 2

# Сортировка вставками O(n^2)

- устойчивая, в отличие от **сортировки выбором**

Кратко. Массив разделяется на две части (сортированная и нет). На каждом шаге число переходит от неотсортированной части к сортированной, и так пока все числе не окажутся в отсортированной части.

Шаги:
1) Все значения неотсортированны. Возьмем первое неотсортированное значение и вставим его в отсортированную часть
2) Берем каждый неотсортированный элемент и сравниваем его со значениями в отсортированной части справа налево, пока не найдем для него подходящую позицию
3) Затем отсортированные элементы, которые находятся справа сдвигаем, чтобы образовать место для элемента

Для каждого неотсортированного элемента нужно:
1) определить место
2) сдвинуть остортированные элементы справа на одну позицию вправо
3) вставить элемент

# Сортировка слиянием O(Nlog N)

- рекурсивный подход
- работает независимот от того, отсортирован или нет

Шаги:
1) Делим массив на части, пока он не будет равен 1-му элементу. Каждый 1 элемент является отсортированным
2) Сливаем их в правильном порядке
3) Сначала получаем группы по два отсортированных элемента, потом четыре

Методы для работы алгоритма:
1) Раздления массива на группы
3) Слияние в правильном порядке

# Быстрая сортировка O(Nlog N)

- рекурсивный подход

Шаги:
1) Выбирается ключевой элемент (допустим, случайшно)
2) Перемещаем все элементы больше ключевого в правую часть массива, а меньшие элементы - в левую
3) Повторяем первые два шага, пока не отсортируем
