# **`Конструкция try..catch..finally`**

- try обязателен
- catch или finally можно опустить

С точки производительности try..catch более накладно, чем применение условных конструкций. 

# **`Блок catch и фильтры исключений`**

Формы:
- catch {..}
- catch (тип_исключения) {..}
- catch (тип_исключения имя_переменной) {..}

## **Фильтры исключений**

Позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения используется выражение when.

# **`Типы исключений. Класс Exception`**

- базовый для все типов исключений, является тип Exception
- создание своего типа исключения, надо наследоваться от класса Exception

# **`Поиск блока catch при обработке исключений`**

Если код, который вызывает исключение, не размещен в блоке try или помещен в конструкцию try..catch, которая не содержит для обработки соответствующего блока catch, то система производит поиск соответствующего блока catch в стеке вызовов.

# **`Генерация исключения и оператор throw`**

- для генерирования исключения вручную

У него есть два вида реализации:
- throw new Exception()
- throw (работает только в блоке catch) - если блок try..catch помещен внутри другого блока try..catch - то throw передает обработку наверх.

# **`Есть случаи, когда блок finally не выполняется`**

- Environment.FailFast("message")

Это статический метод, который мгновенно завершает работу приложения, не попадая в какие-либо блоки исключений.

Сообщение, поясняющее, почему процесс был завершен, или не содержащее никаких объяснений

- Сбой питания

Блок finally вызывается даже если исключение не обрабатывается ни в одном из блоков catch в стеке вызовов, но это зависит от того, как развертываются исключения, что в свою очередь зависит от настроек компьютера. Лично у меня вызываются даже при необработанном исключении.